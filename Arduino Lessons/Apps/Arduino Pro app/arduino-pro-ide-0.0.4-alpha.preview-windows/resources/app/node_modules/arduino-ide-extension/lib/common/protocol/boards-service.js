"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var os_1 = require("@theia/core/lib/common/os");
var naturalCompare = require('string-natural-compare').caseInsensitive;
var AttachedBoardsChangeEvent;
(function (AttachedBoardsChangeEvent) {
    function diff(event) {
        var diff = function (left, right) {
            return left.filter(function (item) { return right.indexOf(item) === -1; });
        };
        var newBoards = event.newState.boards;
        var oldBoards = event.oldState.boards;
        var newPorts = event.newState.ports;
        var oldPorts = event.oldState.ports;
        return {
            detached: {
                boards: diff(oldBoards, newBoards),
                ports: diff(oldPorts, newPorts)
            },
            attached: {
                boards: diff(newBoards, oldBoards),
                ports: diff(newPorts, oldPorts)
            }
        };
    }
    AttachedBoardsChangeEvent.diff = diff;
})(AttachedBoardsChangeEvent = exports.AttachedBoardsChangeEvent || (exports.AttachedBoardsChangeEvent = {}));
exports.BoardsServiceClient = Symbol('BoardsServiceClient');
exports.BoardsServicePath = '/services/boards-service';
exports.BoardsService = Symbol('BoardsService');
var Port;
(function (Port) {
    var Protocol;
    (function (Protocol) {
        function toProtocol(protocol) {
            if (protocol === 'serial') {
                return 'serial';
            }
            else if (protocol === 'network') {
                return 'network';
            }
            else {
                return 'unknown';
            }
        }
        Protocol.toProtocol = toProtocol;
    })(Protocol = Port.Protocol || (Port.Protocol = {}));
    function toString(port, options) {
        if (options === void 0) { options = { useLabel: false }; }
        if (options.useLabel && port.label) {
            return port.address + " " + port.label;
        }
        return port.address;
    }
    Port.toString = toString;
    function compare(left, right) {
        // Board ports have higher priorities, they come first.
        if (isBoardPort(left) && !isBoardPort(right)) {
            return -1;
        }
        if (!isBoardPort(left) && isBoardPort(right)) {
            return 1;
        }
        var result = left.protocol.toLocaleLowerCase().localeCompare(right.protocol.toLocaleLowerCase());
        if (result !== 0) {
            return result;
        }
        result = naturalCompare(left.address, right.address);
        if (result !== 0) {
            return result;
        }
        return (left.label || '').localeCompare(right.label || '');
    }
    Port.compare = compare;
    function equals(left, right) {
        if (left && right) {
            return left.address === right.address
                && left.protocol === right.protocol
                && (left.label || '') === (right.label || '');
        }
        return left === right;
    }
    Port.equals = equals;
    // Based on: https://github.com/arduino/Arduino/blob/93581b03d723e55c60caedb4729ffc6ea808fe78/arduino-core/src/processing/app/SerialPortList.java#L48-L74   
    function isBoardPort(port) {
        var address = port.address.toLocaleLowerCase();
        if (os_1.isWindows) {
            // `COM1` seems to be the default serial port on Windows.
            return address !== 'COM1'.toLocaleLowerCase();
        }
        // On macOS and Linux, the port should start with `/dev/`.
        if (!address.startsWith('/dev/')) {
            return false;
        }
        if (os_1.isOSX) {
            // Example: `/dev/cu.usbmodem14401`
            if (/(tty|cu)\..*/.test(address.substring('/dev/'.length))) {
                return [
                    '/dev/cu.MALS',
                    '/dev/cu.SOC',
                    '/dev/cu.Bluetooth-Incoming-Port'
                ].map(function (a) { return a.toLocaleLowerCase(); }).every(function (a) { return a !== address; });
            }
        }
        // Example: `/dev/ttyACM0`
        if (/(ttyS|ttyUSB|ttyACM|ttyAMA|rfcomm|ttyO)[0-9]{1,3}/.test(address.substring('/dev/'.length))) {
            // Default ports were `/dev/ttyS0` -> `/dev/ttyS31` on Ubuntu 16.04.2.
            if (address.startsWith('/dev/ttyS')) {
                var index = Number.parseInt(address.substring('/dev/ttyS'.length), 10);
                if (!Number.isNaN(index) && 0 <= index && 31 >= index) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    Port.isBoardPort = isBoardPort;
    function sameAs(left, right) {
        if (left && right) {
            if (left.protocol !== 'serial') {
                console.log("Unexpected protocol for port: " + JSON.stringify(left) + ". Ignoring protocol, comparing addresses with " + right + ".");
            }
            return left.address === right;
        }
        return false;
    }
    Port.sameAs = sameAs;
})(Port = exports.Port || (exports.Port = {}));
var Board;
(function (Board) {
    function is(board) {
        return !!board && 'name' in board;
    }
    Board.is = is;
    function equals(left, right) {
        return left.name === right.name && left.fqbn === right.fqbn;
    }
    Board.equals = equals;
    function sameAs(left, right) {
        // How to associate a selected board with one of the available cores: https://typefox.slack.com/archives/CJJHJCJSJ/p1571142327059200
        // 1. How to use the FQBN if any and infer the package ID from it: https://typefox.slack.com/archives/CJJHJCJSJ/p1571147549069100
        // 2. How to trim the `/Genuino` from the name: https://arduino.slack.com/archives/CJJHJCJSJ/p1571146951066800?thread_ts=1571142327.059200&cid=CJJHJCJSJ
        var other = typeof right === 'string' ? { name: right } : right;
        if (left.fqbn && other.fqbn) {
            return left.fqbn === other.fqbn;
        }
        return left.name.replace('/Genuino', '') === other.name.replace('/Genuino', '');
    }
    Board.sameAs = sameAs;
    function compare(left, right) {
        var result = left.name.localeCompare(right.name);
        if (result === 0) {
            result = (left.fqbn || '').localeCompare(right.fqbn || '');
        }
        return result;
    }
    Board.compare = compare;
    function installed(board) {
        return !!board.fqbn;
    }
    Board.installed = installed;
    function toString(board, options) {
        if (options === void 0) { options = { useFqbn: true }; }
        var fqbn = options && options.useFqbn && board.fqbn ? " [" + board.fqbn + "]" : '';
        return "" + board.name + fqbn;
    }
    Board.toString = toString;
})(Board = exports.Board || (exports.Board = {}));
var AttachedSerialBoard;
(function (AttachedSerialBoard) {
    function is(b) {
        return !!b && 'port' in b;
    }
    AttachedSerialBoard.is = is;
})(AttachedSerialBoard = exports.AttachedSerialBoard || (exports.AttachedSerialBoard = {}));
var AttachedNetworkBoard;
(function (AttachedNetworkBoard) {
    function is(b) {
        return 'address' in b && 'port' in b;
    }
    AttachedNetworkBoard.is = is;
})(AttachedNetworkBoard = exports.AttachedNetworkBoard || (exports.AttachedNetworkBoard = {}));
//# sourceMappingURL=boards-service.js.map